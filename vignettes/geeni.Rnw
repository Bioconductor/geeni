%\VignetteIndexEntry{Bounded memory GEE with geeni}
%\VignetteDepends{ff, nlme, BiocParallel, IRanges}
%\VignetteKeywords{GEE, bounded memory computations}
%\VignettePackage{geeni}

\documentclass{article}

\usepackage[authoryear,round]{natbib}

<<style, eval=TRUE, echo=FALSE, results=tex>>=
BiocStyle::latex(use.unsrturl=FALSE)
@

\title{Bounded memory GEE with \Biocpkg{geeni}}
\author{VJ Carey}
\date{Edited: April 2014; Compiled: \today}

\begin{document}

\maketitle

\tableofcontents

<<options, echo=FALSE>>=
options(width=72)
options("showHeadLines" = 3)
options("showTailLines" = 3)
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

This is a very simple approach to illustrating three principles of 
deployable statistical methodology. First, data are accessed flexibly, 
without the requirement that all records can be accessed simultaneously 
in main memory. Second, computations are isolated where possible so that 
they may be dispatched to parallel workers. Third, effort is made to 
maximize reuse of existing numerical / statistical facilities in base \R{} 
packages to program a generalized estimating equation (GEE) solver. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Out of memory data}

We want a representation of grouped data that can be manipulated with
a small memory footprint.  We store two data components on disk
that allow retrieval of individual groups based on \Robject{ff}
objects.

We use the orthodontistry dataset from the \Rpackage{nlme} to create
a \Robject{groupedData} object.

<<build_groupedData>>=
library(geeni)
library(nlme)
  Orth.new <-
       groupedData(distance ~ age | Subject,
                   data = as.data.frame(Orthodont),
                   FUN = mean,
                   outer = ~ Sex,
                   labels = list(x = "Age",
                     y = "Distance from pituitary to pterygomaxillary fissure"),
                   units = list( x = "(yr)", y = "(mm)"))
dim(Orth.new)
@

The \Rfunction{gd2flat} function builds an \emph{out-of-memory} clustered 
data set using the \Rfunction{ff} function in the \Rpackage{ff} package.

<<build_ff>>=
flatOrth <- gd2flat(gd=Orth.new, gcol=3, prefix="")
flatOrth
@

\Robject{flatOrth} is a \Robject{gdManager} object which manages access 
to the information in the files we created on disk. The key task 
supported by the manager is retrieval of a specified cluster of observations
using the \Rfunction{getGrp} method:

<<lkg>>=
getGrp(flatOrth, 1)
getGrp(flatOrth, 4)
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Independent computations}

In this section we identify the portions of our problem that can be
isolated and run in parallel.

Generalized estimating equations are an extension to generalized
linear models (GLMs) to accomodate the modeling of correlated data.
The general steps are as follows.

\begin{itemize}
  \item Compute initial parameter estimates with GLM
        (assumes observations within subjects are independent)
  \item Calculate residuals from naive model (observed - predicted)
  \item Calculate working correlation matrix from residuals
  \item Re-fit regression coefficients using corrected correlation
        (iterative process)
\end{itemize}

The Newton-Raphson algorithm is one approach to solving the system of
estimating equations. The parameter update step of the Newton-Raphson is 
independent for each data cluster and therefore a good candidate for 
parallel computation. In this section we write a function to isolate 
the parameter update step and demonstrate parallel execution with 
functions from the \Biocpkg{BiocParallel} package.

Model \emph{link} and \emph{variance} components are specified by an 
\R{} \Robject{family} object. 

For $I$ observed clusters indexed by $i$, let $y_i$ denote an $n_i \times 1$
response vector satisfying 
\[
E[y_i|x_i] = \mu_i(\beta) = g^{-1}( x_i \beta),
\] 
\[
\mbox{var}(y_i) = V(\mu_i)
\]
where $x_i$ is $n_i \times p$ matrix of covariates, and
$g(\cdot)$ and $V(\cdot)$ are link and variance functions from the family
of GLMs and $D$ is a matrix of derivatives. We will eventually accommodate a 
working intracluster correlation model, but for now adopt working independence.

We want to solve
\[
\sum_i \frac{\partial \mu_i(\beta)}{\partial \beta}^t V^{-1}(\mu_i)[y_i - \mu_i(\beta)] = 
\sum_i D_i^t V_i^{-1}r_i = 0
\]
for $\beta$ by iterating 
\[
\hat{\beta}^{(s)} = \hat{\beta}^{(s-1)} + (\sum_i D_i^t V^{-1}_i D_i)^{-1}(\sum_i D_i^t V^{-1}_i r_i)
\]
over $s = 1, \ldots$ until convergence.

In each iteration, the standard error will be computed as

\[
(D_i^{t} V_i^{-1} D_i)^{-1}(D_i^{t} V^{-1} E_i V_i^{-1} D_i)(D_i^{t} V_i^{-1} D_i)^{-1}
\]

where $E$ is a diagonal matrix of $r_i$ values.

The \Rfunction{delb} function performs a single update step for \emph{beta}:

<<doco>>=
delb <- function(gd, beta, family) {
    DD <- Di(gd, 1, beta, family)
    val <- t(DD) %*% Vinv.i(gd, 1, beta, family) 
    val1 <- val %*% DD
    val2 <- val %*% ri(gd, 1, beta, family)
    for  (i in 2:length(gd@discrim)) {
        DD <- Di(gd, i, beta, family)
        val <- t(DD) %*% Vinv.i(gd, i, beta, family) 
        val1 <- val1 + val %*% DD
        val2 <- val2 + val %*% ri(gd, i, beta, family)
    }
    solve(val1) %*% val2
}
@

Compute one update step from an initial value of zero:

<<update_step>>=
delb(flatOrth, beta = c(0, 0, 0), family = gaussian)
@

We compare our output with the \Rfunction{groupedData} man page
example from the \Rpackage{nlme} package. For the Gaussian model the 
constituents seem to be correct. 

<<lkg,eval=TRUE,echo=FALSE,results=hide>>=
example(groupedData)
@

Any discrepancy in the intercept is attributable to different factor 
coding for Sex.

<<lklm>>=
lm(distance ~ age + Sex, data = Orth.new)
@

We now factor the problem so quantities for each cluster are computed 
separately. \Rfunction{bplapply} from \Rpackage{BiocParallel} distributes 
quantities for each data cluster to workers. Results are combined 
across workers with the \Rfunction{combi} function and the beta 
parameter is updated.

Set the initial beta vector to zero. The three values represent
the intercept, age and sex.
<<multiple_iteration_1>>=
beta <- c(0, 0, 0)
clusters <- seq_along(discrim(flatOrth))
@

The first call to \Rfunction{Gcomps} produces the first estimates.
<<multiple_iteration_2>>=
comps <- combi(bplapply(clusters, Gcomps, flatOrth, beta, gaussian)) 
comps
@

Beta is updated and \Rfunction{Gcomps} is called again.
<<multiple_iteration_3>>=
beta <- beta + (solve(comps[[1]]) %*% comps[[2]])
comps <- combi(bplapply(clusters, Gcomps, flatOrth, beta, gaussian)) 
comps
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Generic solver}


Putting these steps together we create a generic solver in the 
single function \Rfunction{pargee}.

<<dog>>=
pargee(flatOrth, gaussian, c(0, 0, 0))
@

If necessary, adjust the coding discrepancy for the Sex factor:

<<domore,eval=FALSE,keep.source=TRUE>>=
flatOrth@numdat[,"Sex"] = flatOrth@numdat[,"Sex"]-1  # overwrite allowed
@

Remove the ff data:

<<killff>>=
system("rm -rf .dat.ff")
system("rm -rf .disc.ff")
@
 
<<lkses>>=
sessionInfo()
@

\end{document}
